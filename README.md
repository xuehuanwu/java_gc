什么是GC,GC在什么时候，对什么东西，做了什么事情？？？

什么是GC？
Java的内存管理实际上就是对象的管理，其中包括对象的分配和释放。
对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆（heap）中的所有对象。
通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。
但是， 为了保证GC能够在不同平台实现的问题，Java规范对GC的很多行为都没有进行严格的规定。
例如，对于采用什么类型的回收算法、什么时候进行回收等重要问题都没有明确的规定。因此，不同的JVM的实现者往往有不同的实现算法

在什么时候？
1.新生代有一个有一个Eden区和两个survivor区（默认比例为8:1，两个suivivor区，一个叫from ,一个叫to），首先将对象放入Eden区，
如果空间不足就向其中一个survivor区上放，如果仍然放不下，就会引发一次在新生代的minor GC，将存活的对象放入另一个survivor去中，
然后清空Eden和之前的那个survivor的内存，在某次GC过程中，如果发现仍然有放不下的对象，就将这些对象放入老年代内存中。
（因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，
每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。）
2.大对象以及长期存活的对象直接进入老年区。
3.当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小，
那么执行一次Full GC以尽可能的获得老年区的空间。

对什么东西？
从GC Roots搜索不到，而且经历过一次标记清理之后仍然没有复活的对象。
java提供finalize()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。
(1).对象不一定会被回收。
(2).垃圾回收不是析构函数。
(3).垃圾回收只与内存有关。
(4).垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。

那么怎么复活？
重写finalized方法，在方法里给对象以引用，但只能复活一次。在垃圾回收过程中，不能对复活对象调用 Finalize。

GC Roots都有哪些
1.虚拟机栈中的引用的对象
2.方法区中静态属性引用的对象
3.常量引用的对象
4.本地方法栈中JNI(即一般说的native方法引用的对象

做什么？
新生代：复制清理；
老年代：标记-清除和标记-压缩算法
永久代：存放Java中的类和加载类的类加载器本身

什么是Minor gc、Full gc、Major gc
从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC
Major GC 是清理老年代
Full GC 是清理整个堆空间—包括年轻代和老年代
